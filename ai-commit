#!/usr/bin/env python3

import sys
import subprocess
import re
import os
import xml.etree.ElementTree as ET
import tempfile
import argparse

def main():
    parser = argparse.ArgumentParser(description='Generate AI-powered commit messages')
    parser.add_argument('--amend', action='store_true', help='Amend the previous commit')
    parser.add_argument('--message', '-m', help='Initial commit message')
    args = parser.parse_args()
    
    # Determine which AI command to use
    command = os.environ.get("AI_HELPER_COMMAND", "claude").lower()
    
    # Get specific model configuration
    model = os.environ.get("AI_HELPER_MODEL")
    
    # Exit early if a rebase is in progress
    git_dir = subprocess.check_output(['git', 'rev-parse', '--git-dir'], text=True).strip()
    rebase_paths = [
        os.path.join(git_dir, 'rebase-merge'),
        os.path.join(git_dir, 'rebase-apply'),
        os.path.join(git_dir, 'REBASE_HEAD'),
        os.path.join(git_dir, 'CHERRY_PICK_HEAD'),
    ]
    
    if any(os.path.exists(path) for path in rebase_paths):
        print("Cannot generate commit message during rebase/cherry-pick operation")
        sys.exit(1)
    
    # Check if there are staged changes (or if amending)
    if not args.amend:
        diff = subprocess.check_output(['git', 'diff', '--cached'], text=True)
        if not diff:
            print("No staged changes found. Stage your changes with 'git add' first.")
            sys.exit(1)
    else:
        # For amend, get the diff of the last commit
        diff = subprocess.check_output(['git', 'diff', 'HEAD~1..HEAD'], text=True)
    
    # Get initial message
    if args.message:
        initial_msg = args.message
    elif args.amend:
        # Get the previous commit message
        initial_msg = subprocess.check_output(['git', 'log', '-1', '--pretty=%B'], text=True).strip()
    else:
        initial_msg = ""
    
    try:
        branch_name = subprocess.check_output(['git', 'branch', '--show-current'], text=True).strip()
        
        # Determine primary branch dynamically
        base_branch = 'main'  # Default fallback
        try:
            # Try to get the default branch from remote HEAD
            result = subprocess.check_output(['git', 'symbolic-ref', 'refs/remotes/origin/HEAD'], text=True, stderr=subprocess.DEVNULL).strip()
            base_branch = result.split('/')[-1]
        except subprocess.CalledProcessError:
            # Fallback: check common branch names
            for branch in ['main', 'master', 'develop']:
                try:
                    subprocess.check_output(['git', 'show-ref', '--verify', '--quiet', f'refs/heads/{branch}'], stderr=subprocess.DEVNULL)
                    base_branch = branch
                    break
                except subprocess.CalledProcessError:
                    continue
        
        # Handle repositories with no commits
        try:
            branch_diff = subprocess.check_output(['git', 'diff', f'{base_branch}...HEAD'], text=True, stderr=subprocess.DEVNULL)
        except subprocess.CalledProcessError:
            # If there are no commits, compare to empty tree
            branch_diff = subprocess.check_output(['git', 'diff', '--cached'], text=True)
        
        try:
            recent_commits = subprocess.check_output(['git', 'log', '--oneline', '-5'], text=True, stderr=subprocess.DEVNULL)
        except subprocess.CalledProcessError:
            # No commits exist yet
            recent_commits = "(This is the first commit in the repository)"
    except subprocess.CalledProcessError:
        sys.exit(1)
    
    # Create the prompt for the selected model
    prompt = f"""
You are an AI assistant specialized in rewriting Git commit messages to be clear, detailed, and helpful. Your task is to analyze the provided information and generate an improved commit message.

First, review the following context:

1. Staged Changes (This Commit):
<staged_diff>
{diff}
</staged_diff>

2. Full Branch Changes:
<branch_diff>
{branch_diff}
</branch_diff>

3. Branch Information:
<branch_context>
Current Branch: {branch_name}
Base Branch: {base_branch}
</branch_context>

4. Recent Commits:
<recent_commits>
{recent_commits}
</recent_commits>

5. User's Draft Message:
<user_message>
{initial_msg}
</user_message>

Now, follow these steps to generate an improved commit message:

1. Analyze the provided information:
   - Understand the context of the change within the broader feature or fix being worked on.
   - Examine the staged changes and full branch changes.
   - Consider the recent commit history and branch information.

2. Break down your thought process inside <change_analysis> tags:
   - Summarize the main changes, quoting specific parts of the diffs and recent commits.
   - Categorize the type of change (e.g., feature addition, bug fix, refactoring).
   - Explain potential reasons for these changes based on the context.
   - List any potential implications or side effects of the changes.
   - State your confidence level in understanding the intent (e.g., "I'm very confident", "I'm somewhat confident", "I'm not confident").
   - List any questions or uncertainties about the changes.

3. Compose the rewritten commit message:
   - Start with a short, descriptive title (less than 80 characters).
   - If the intent is clear, include additional paragraphs explaining why the change was made.
   - If the intent is not clear, provide only a short summary of the change in the title.
   - Use blank lines to separate paragraphs.
   - Ensure the message is professional, descriptive, and accurately reflects the changes.
   - Do not include affirmations or comment on the correctness of the changes.

4. Review and refine your message:
   - Ensure it meets all the requirements mentioned above.
   - Check that it accurately reflects the changes without any erroneous descriptions.

5. Format your response using these XML tags:
<change_analysis>
[Your detailed analysis of the changes]
</change_analysis>

<commit_message>
[Your generated commit message - can be multi-line with title and description]
</commit_message>

Example output structure (note: this is a generic example, your actual content will vary based on the specific changes):

<change_analysis>
Main changes:
1. [Description of first major change]
   Quote from diff: "[relevant code snippet]"
2. [Description of second major change]
   Quote from diff: "[relevant code snippet]"
3. [Description of third major change]
   Quote from recent commit: "[relevant commit message]"

Change category: [feature addition/bug fix/refactoring]

These changes appear to be related to [feature/bug fix/refactoring]. Based on the recent commit history, it seems that this is part of a larger effort to [overall goal].

Potential implications:
- [Implication 1]
- [Implication 2]

I'm [confidence level] about the intent of these changes. [Explanation of confidence level]

Questions/uncertainties:
- [Question 1]
- [Question 2]
</change_analysis>

<commit_message>
[Short, descriptive title less than 80 characters]

[Paragraph explaining the reason for the change, if intent is clear]

[Additional paragraph with more details, if necessary]

[Final paragraph summarizing the impact or importance of the change]
</commit_message>

Remember to prioritize accuracy, clarity, and helpfulness in your analysis and commit message. Your goal is to provide a commit message that will be valuable for other developers reviewing the code changes.
"""
    
    # Call the selected AI command
    try:
        # Build command with model parameter if specified
        cmd = [command]
        if model:
            cmd.extend(["--model", model])
            
        result = subprocess.run(cmd, input=prompt, text=True, capture_output=True)
        if result.returncode != 0:
            print(f"Error calling {command.capitalize()} CLI")
            sys.exit(1)
        rewritten_msg = result.stdout.strip()
    except FileNotFoundError:
        print(f"{command.capitalize()} CLI not found. Please install it first.")
        sys.exit(1)
    
    # Parse response using proper XML parsing
    analysis = ""
    commit_message = ""
    
    try:
        # Wrap the response in a root element to make it valid XML
        xml_content = f"<root>{rewritten_msg}</root>"
        root = ET.fromstring(xml_content)
        
        # Extract analysis if present
        analysis_elem = root.find('change_analysis')
        if analysis_elem is not None:
            analysis = analysis_elem.text.strip() if analysis_elem.text else ""
        
        # Extract commit message
        commit_msg_elem = root.find('commit_message')
        if commit_msg_elem is not None:
            commit_message = commit_msg_elem.text.strip() if commit_msg_elem.text else ""
            
    except ET.ParseError:
        # Fallback to regex if XML parsing fails
        analysis_match = re.search(r'<change_analysis>(.*?)</change_analysis>', rewritten_msg, re.DOTALL)
        if analysis_match:
            analysis = analysis_match.group(1).strip()
        
        commit_msg_match = re.search(r'<commit_message>(.*?)</commit_message>', rewritten_msg, re.DOTALL)
        if commit_msg_match:
            commit_message = commit_msg_match.group(1).strip()
        else:
            # If no XML tags found, use the whole response as commit message
            commit_message = rewritten_msg
            # Remove analysis from commit message if found
            commit_message = re.sub(r'<change_analysis>.*?</change_analysis>', '', commit_message, flags=re.DOTALL)
    
    # Clean any markdown code block output from commit message
    commit_message = re.sub(r'^```.*$', '', commit_message, flags=re.MULTILINE)
    commit_message = re.sub(r'^# ', '', commit_message, flags=re.MULTILINE)
    commit_message = re.sub(r'\n\s*\n\s*\n', '\n\n', commit_message)  # Collapse multiple blank lines
    commit_message = commit_message.strip()
    
    # Show result to user
    print("\n")
    
    # Show analysis if available
    if analysis:
        print(f"{command.capitalize()}'s Analysis:")
        print("-" * 60)
        print(analysis)
        print("-" * 60)
        print()
    
    print(f"{command.capitalize()}'s Suggested Commit Message:")
    print("-" * 60)
    print(commit_message)
    print("-" * 60)
    print()
    print("Choose what to do:")
    print("1) Use it")
    print("2) Edit it")
    print("3) Keep original (or write new)")
    print("4) Cancel")
    
    while True:
        try:
            choice = input("Enter your choice (1-4): ").strip()
            if choice == "1":
                # Create commit with the message
                if args.amend:
                    subprocess.run(['git', 'commit', '--amend', '-m', commit_message])
                else:
                    subprocess.run(['git', 'commit', '-m', commit_message])
                sys.exit(0)
            elif choice == "2":
                # Write to temp file and open editor
                with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                    f.write(commit_message)
                    temp_file = f.name
                
                editor = os.environ.get('EDITOR', 'vi')
                subprocess.call([editor, temp_file])
                
                with open(temp_file, 'r') as f:
                    edited_msg = f.read().strip()
                
                os.unlink(temp_file)
                
                if edited_msg:
                    if args.amend:
                        subprocess.run(['git', 'commit', '--amend', '-m', edited_msg])
                    else:
                        subprocess.run(['git', 'commit', '-m', edited_msg])
                else:
                    print("Empty message, cancelling commit")
                    sys.exit(1)
                sys.exit(0)
            elif choice == "3":
                # Let user write their own message
                if args.amend:
                    subprocess.run(['git', 'commit', '--amend'])
                else:
                    subprocess.run(['git', 'commit'])
                sys.exit(0)
            elif choice == "4":
                print("Cancelled.")
                sys.exit(1)
            else:
                print("Please choose a valid option (1-4).")
        except KeyboardInterrupt:
            print("\nCancelled.")
            sys.exit(1)
        except EOFError:
            print(f"\nUsing {command.capitalize()}'s suggestion (default choice).")
            if args.amend:
                subprocess.run(['git', 'commit', '--amend', '-m', commit_message])
            else:
                subprocess.run(['git', 'commit', '-m', commit_message])
            sys.exit(0)

if __name__ == "__main__":
    main()