#!/usr/bin/env python3

import sys
import subprocess
import re
import os

def run_command(cmd):
    """Run a shell command and return the output"""
    try:
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        return result.stdout.strip() if result.returncode == 0 else ""
    except Exception:
        return ""

def run_command_check(cmd):
    """Run a shell command and return success status"""
    try:
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        return result.returncode == 0
    except Exception:
        return False

def is_git_repo():
    """Check if we're in a git repository"""
    return run_command_check("git rev-parse --git-dir > /dev/null 2>&1")

def get_current_branch():
    """Get the current branch name"""
    branch = run_command("git branch --show-current")
    return branch if branch else None

def get_main_branch():
    """Determine the main branch (main or master)"""
    if run_command_check("git rev-parse --verify origin/main > /dev/null 2>&1"):
        return "main"
    elif run_command_check("git rev-parse --verify origin/master > /dev/null 2>&1"):
        return "master"
    return None

def main():
    additional_context = sys.argv[1] if len(sys.argv) > 1 else ""
    
    # Check if we're in a git repository
    if not is_git_repo():
        print("Error: Not in a git repository", file=sys.stderr)
        sys.exit(1)

    # Get current branch name
    current_branch = get_current_branch()
    if not current_branch:
        print("Error: Could not determine current branch (detached HEAD?)", file=sys.stderr)
        sys.exit(1)

    # Check if we're on main/master branch
    if current_branch in ["master", "main"]:
        print("Error: Cannot create PR from main/master branch", file=sys.stderr)
        sys.exit(1)

    # Check if branch has upstream and is pushed to remote
    if not run_command_check(f"git rev-parse --verify origin/{current_branch} > /dev/null 2>&1"):
        print(f"Error: Branch '{current_branch}' not found on remote. Push the branch first.", file=sys.stderr)
        sys.exit(1)

    # Get the main branch (prefer main over master)
    main_branch = get_main_branch()
    if not main_branch:
        print("Error: Could not find main or master branch on remote", file=sys.stderr)
        sys.exit(1)

    print("Generating PR description with Claude Code...", file=sys.stderr)

    # Get commit history for this branch (from main branch)
    commit_log = run_command(f"git log {main_branch}..{current_branch} --oneline")
    if not commit_log:
        print(f"Error: No commits found on branch '{current_branch}' compared to '{main_branch}'", file=sys.stderr)
        sys.exit(1)

    # Get the full diff for context
    try:
        branch_diff = subprocess.check_output(['git', 'diff', f'{main_branch}...{current_branch}'], text=True)
        recent_commits = subprocess.check_output(['git', 'log', '--oneline', '-5'], text=True)
    except subprocess.CalledProcessError:
        print("Error: Failed to get git information", file=sys.stderr)
        sys.exit(1)

    # Create the sophisticated prompt for Claude
    prompt = f"""
You are an AI assistant specialized in generating comprehensive GitHub Pull Request titles and descriptions. Your task is to analyze the provided information and generate a well-structured PR.

First, review the following context:

1. Branch Changes (Full Diff):
<branch_diff>
{branch_diff}
</branch_diff>

2. Branch Information:
<branch_context>
Branch: {current_branch}
Base: {main_branch}
</branch_context>

3. Commit History:
<commit_log>
{commit_log}
</commit_log>

4. Recent Commits for Context:
<recent_commits>
{recent_commits}
</recent_commits>"""

    # Add additional context if provided
    if additional_context:
        prompt += f"""

5. Additional Context:
<additional_context>
{additional_context}
</additional_context>"""

    prompt += """

Now, please follow these steps to generate a comprehensive PR:

1. Analyze the provided information:
   - Understand the overall purpose and scope of the changes
   - Examine the branch changes and commit history
   - Consider the impact and significance of the modifications
   - Identify the type of change (feature, bugfix, refactor, etc.)

2. Wrap your analysis inside <pr_analysis> tags:
   - Summarize the main changes you've identified
   - Explain the potential reasons for these changes
   - Determine the scope and impact of the changes
   - Identify any notable patterns or themes in the commits
   - State your confidence level in understanding the intent

3. Generate the PR title and description:
   - Create a concise, descriptive title (ideally less than 80 characters)
   - Write a comprehensive description explaining:
     * What changes were made
     * Why the changes were necessary
     * Any notable implementation details
     * Impact on the codebase or users
   - Use proper markdown formatting
   - Include any relevant testing notes or considerations

4. Format your response as:
TITLE: [Your generated title]
DESCRIPTION: [Your generated description]

Please ensure the title and description are professional, accurate, and provide clear value to code reviewers.

<pr_analysis>
"""

    # Call Claude CLI
    try:
        result = subprocess.run(['claude'], input=prompt, text=True, capture_output=True)
        if result.returncode != 0:
            print("Error: Failed to generate PR title and description with Claude Code", file=sys.stderr)
            print("This could be due to a Claude Code installation issue.", file=sys.stderr)
            print("As a fallback, here's the prompt you can copy and paste to Claude Code:", file=sys.stderr)
            print("─" * 60, file=sys.stderr)
            print(prompt, file=sys.stderr)
            print("─" * 60, file=sys.stderr)
            sys.exit(1)
        pr_response = result.stdout.strip()
    except FileNotFoundError:
        print("Error: Claude CLI not found. Please install it first.", file=sys.stderr)
        sys.exit(1)

    # Parse the response
    analysis = ""
    pr_title = ""
    pr_description = ""
    
    # Extract analysis if present
    analysis_match = re.search(r'<pr_analysis>(.*?)</pr_analysis>', pr_response, re.DOTALL)
    if analysis_match:
        analysis = analysis_match.group(1).strip()
        # Remove analysis from response for cleaner parsing
        pr_response_clean = re.sub(r'<pr_analysis>.*?</pr_analysis>', '', pr_response, flags=re.DOTALL)
    else:
        pr_response_clean = pr_response

    # Parse the title and description from the response
    title_match = re.search(r'^\*\*TITLE:\*\*\s*(.+)$|^TITLE:\s*(.+)$', pr_response_clean, re.MULTILINE)
    if title_match:
        pr_title = title_match.group(1) or title_match.group(2)
        pr_title = pr_title.strip()
    
    # Extract everything after DESCRIPTION: line
    desc_match = re.search(r'^\*\*DESCRIPTION:\*\*\s*(.*)$|^DESCRIPTION:\s*(.*)$', pr_response_clean, re.MULTILINE | re.DOTALL)
    if desc_match:
        pr_description = desc_match.group(1) or desc_match.group(2)
        pr_description = pr_description.strip()

    # Clean up the PR description
    # Remove Claude attribution lines and trim leading/trailing whitespace
    pr_description = re.sub(r'🤖 Generated with \[Claude Code\].*$', '', pr_description, flags=re.MULTILINE)
    pr_description = pr_description.strip()

    # Fallback to branch name if title parsing failed
    if not pr_title:
        pr_title = current_branch.replace('-', ' ').replace('_', ' ').title()

    # Add the footer
    pr_description = f"{pr_description}\n\nPR description generated from this branch with Claude Code"

    # Show result to user - redirect to terminal
    try:
        with open('/dev/tty', 'w') as tty:
            tty.write("\n")
            
            # Show analysis if available
            if analysis:
                tty.write("Claude's Analysis:\n")
                tty.write("─" * 60 + "\n")
                tty.write(analysis + "\n")
                tty.write("─" * 60 + "\n")
                tty.write("\n")
            
            tty.write("Generated PR Title:\n")
            tty.write("─" * 60 + "\n")
            tty.write(pr_title + "\n")
            tty.write("─" * 60 + "\n")
            tty.write("\n")
            tty.write("Generated PR Description:\n")
            tty.write("─" * 60 + "\n")
            tty.write(pr_description + "\n")
            tty.write("─" * 60 + "\n")
            tty.write("\n")
            tty.write("Choose what to do:\n")
            tty.write("1) Create PR with this title and description\n")
            tty.write("2) Edit title and description\n") 
            tty.write("3) Cancel\n")
    except:
        # Fallback to stderr if /dev/tty is not available
        print(f"\nGenerated PR Title:\n{pr_title}\n", file=sys.stderr)
        print(f"Generated PR Description:\n{pr_description}\n", file=sys.stderr)

    # Interactive choice
    while True:
        try:
            # Force connection to terminal for interactive input
            sys.stdin = open('/dev/tty', 'r')
            sys.stdout = open('/dev/tty', 'w')
            choice = input("Enter your choice (1-3): ").strip()
            
            if choice == "1":
                # Create the PR using gh CLI
                if not subprocess.run(['which', 'gh'], capture_output=True).returncode == 0:
                    print("Error: GitHub CLI (gh) not found. Please install it to create PRs automatically.", file=sys.stderr)
                    print("Alternatively, you can copy the description above and create the PR manually.", file=sys.stderr)
                    sys.exit(1)
                
                try:
                    result = subprocess.run([
                        'gh', 'pr', 'create', 
                        '--title', pr_title,
                        '--body', pr_description,
                        '--base', main_branch,
                        '--draft'
                    ], capture_output=True, text=True)
                    
                    if result.returncode == 0:
                        print("✅ Draft PR created successfully!")
                        # Extract PR URL from gh output if available
                        if result.stderr:
                            print(result.stderr.strip())
                        sys.exit(0)
                    else:
                        print("❌ Failed to create PR", file=sys.stderr)
                        if result.stderr:
                            print(result.stderr.strip(), file=sys.stderr)
                        sys.exit(1)
                except Exception as e:
                    print(f"❌ Failed to create PR: {e}", file=sys.stderr)
                    sys.exit(1)
                    
            elif choice == "2":
                # Edit the title and description
                import tempfile
                with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False) as f:
                    f.write(f"# PR Title\n{pr_title}\n\n# PR Description\n{pr_description}")
                    temp_file = f.name
                
                editor = os.environ.get('EDITOR', 'vi')
                subprocess.call([editor, temp_file])
                
                # Read back the edited content
                with open(temp_file, 'r') as f:
                    edited_content = f.read()
                
                # Parse the edited content
                lines = edited_content.split('\n')
                title_section = False
                desc_section = False
                edited_title = ""
                edited_desc = []
                
                for line in lines:
                    if line.strip() == "# PR Title":
                        title_section = True
                        desc_section = False
                        continue
                    elif line.strip() == "# PR Description":
                        title_section = False
                        desc_section = True
                        continue
                    elif line.startswith("#"):
                        title_section = False
                        desc_section = False
                        continue
                    
                    if title_section and line.strip():
                        edited_title = line.strip()
                        title_section = False
                    elif desc_section:
                        edited_desc.append(line)
                
                pr_title = edited_title if edited_title else pr_title
                pr_description = '\n'.join(edited_desc).strip() if edited_desc else pr_description
                
                # Clean up temp file
                os.unlink(temp_file)
                
                # Now create the PR with edited content
                try:
                    result = subprocess.run([
                        'gh', 'pr', 'create', 
                        '--title', pr_title,
                        '--body', pr_description,
                        '--base', main_branch,
                        '--draft'
                    ], capture_output=True, text=True)
                    
                    if result.returncode == 0:
                        print("✅ Draft PR created successfully with your edits!")
                        if result.stderr:
                            print(result.stderr.strip())
                        sys.exit(0)
                    else:
                        print("❌ Failed to create PR", file=sys.stderr)
                        if result.stderr:
                            print(result.stderr.strip(), file=sys.stderr)
                        sys.exit(1)
                except Exception as e:
                    print(f"❌ Failed to create PR: {e}", file=sys.stderr)
                    sys.exit(1)
                    
            elif choice == "3":
                # Cancel
                print("PR creation cancelled.")
                sys.exit(0)
            else:
                print("Please choose a valid option (1-3).")
                
        except KeyboardInterrupt:
            print("\nPR creation cancelled.")
            sys.exit(1)
        except EOFError:
            # Default to creating PR when EOF is encountered
            print("\nCreating PR with generated content (default choice).")
            choice = "1"
            continue

if __name__ == "__main__":
    main()